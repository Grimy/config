#!/usr/bin/perl

use strict;
use feature qw(state);
use List::Util qw(first sum max);

my %files = ();
my @colors = ("", "\e[0;33m", "\e[1;31m", "\e[0;31m"),
my ($line, $name, $time) = @ARGV;
$|--;

print "\e[H    | usr | sys |     top-cpu     | mem |     top-mem     | read | writ | hdd |";

sub lines(_) {
	my ($file) = @_;
	my $fh = \$files{$file};
	$$fh ? seek $$fh, 0, 0 : open $$fh, '<', $file or die "$file: $!";
	return readline $$fh;
}

sub percent {
	my ($part, $total) = @_;
	my $percent = $total && $part / $total * 100;
	sprintf "$colors[$percent / 30]%3d%%", $percent;
}

sub bytes {
	s;\d\K(\d{3})+\b;qw(k M G T P)[$&=~y///c/3-1];e for @_;
	sprintf "%5s", @_;
}

sub top {
	my ($score, $name) = split ' ', max(@_), 2;
	sprintf " %-10.10s%s", $name, bytes $score;
}

sub cpu {
	state @old, state @new;
	@new = split for first {/^cpu /} lines "/proc/stat";
	@new = ($new[1] + $new[2], $new[3] + $new[5] + $new[6] + $new[7], sum(@new));
	my @result = map percent($new[$_] - $old[$_], $new[2] - $old[2]), 0..1;
	@old = @new;
	@result;
}

sub top_cpu {
	state @old;
	my @new;
	for (map lines, </proc/*/stat>) {
		@_ = split;
		my $cpu = $_[13] + $_[14];
		$new[$_[0]] = ($cpu - $old[$_[0]]) . " " . substr $_[1], 1, -1;
		$old[$_[0]] = $cpu;
	}
	top @new;
}

sub mem {
	my ($total, $free, $buffers, $cached) = grep s/\w+://, lines "/proc/meminfo";
	percent($total - $free - $buffers - $cached, $total);
}

sub top_mem {
	my @mem;
	for (map lines, </proc/*/stat>) {
		@_ = split;
		$mem[$_[0]] = 4096 * $_[23] . ' ' . substr $_[1], 1, -1;
	}
	top @mem;
}

sub io {
	state @old;
	my @new = split ' ', lines "/sys/block/sda/stat";
	my @result = (bytes($new[3] - $old[3]), bytes($new[7] - $old[7]));
	@old = @new;
	@result;
}

sub disk {
	my ($total, $used, $free) = `df -B1 /var` =~ /\b\d+\b/g;
	percent($total - $free, $total);
}

for (;;) {
	printf "\e[%d;0H\e[K%s", $line, join "\e[0m |", $name, cpu(), top_cpu(), mem(), top_mem(), io(), disk(), '';
	sleep $time;
}
